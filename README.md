# 현재 폴더 현황

- HooGame/HooHame -> 콘솔 프로젝트
- Game -> SokobanGame 소코반 게임
- ShootingGame/Wanted4_ShootingGame -> 슈팅게임




# 프로젝트 결과 보고서

## 📌 프로젝트 명 : HooGame(점프 마스터리)

## 1. 프로젝트 개요

- **서비스 소개**: 플랫포머 게임
- **개발 기간**: 26.01 ~ 26.02 / 5일
- **참여 인원**: 1명
- **주요 기능**:
    
    
    | **기능** | **설명** |
    | --- | --- |
    | 물리 구현 1 | Engine.dll에 컴포넌트 형식으로 액터가 물리 사용 가능 |
    | 물리 구현 2 | Engine.dll에 Acotr()에 충돌 레이어를 추가하여 충돌 레이어를 검사 |
    | 물리 구현 3 | Velocity 구현 |
    | Enemy 공격 | Enemy가 Effect(this)를 스폰하면 해당 Enemy 타입에 맞는 공격 진행 |
    | 추상화 레벨 | 주요 기능을 Level을 상속 받은 BaseLevel에 구현 후 BaseLevel을 상속 받아 레벨 관리 |

---

## 2. 기획 목표

### 🔸기획의도 및 목표

- 특정 게임을 모티브를 게임을 제작하기 보다는 실제 엔진에서 자주 사용하고 구현해 보았던 기능을 콘솔로 구현
- 구현 목표 : 물리, 레벨 관리, 적 공격


## 3. 아키텍처 및 워크플로우

### 🔸실행 흐름 및 아키텍처

1. 진입점 및 시스템 초기화 (Initialization)
   
엔트리 포인트: Main.cpp에서 Engine 인스턴스를 생성하고 Run()을 호출하여 하트비트를 시작합니다.

리소스 로드: 초기 구동 시 MainLevel을 mainLevel 포인터에 할당하여 첫 화면을 구성합니다.

2. 메인 메뉴 및 레벨 전환 (Menu & Navigation)

UI 인터랙션: MainLevel에서 사용자의 입력을 대기하며, 선택지에 따라 다음 레벨의 타입을 결정합니다.

레벨 전환 로직: ToggleMenu() 또는 레벨 관리 시스템을 통해 기존 레벨의 자원을 해제하고, 새 레벨(예: GameLevel)을 활성화합니다.

3. 동적 데이터 로딩 (Data Driven Design)
   
외부 자원 활용: GameLevel은 하드코딩된 데이터 대신 Assets/StageX.txt 파일을 파싱하여 맵 구조, 플레이어 위치, 적(Enemy)의 배치를 실시간으로 생성합니다.

확장성: 새로운 스테이지 추가 시 코드 수정 없이 텍스트 파일 추가만으로 대응 가능한 구조입니다.

4. 게임 루프 및 서브시스템 작동 (Core Logic)
   
Input System: 매 프레임 키보드 상태를 업데이트하여 플레이어의 이동 및 액션 명령을 처리합니다.

Physics Engine: Layer 시스템과 TargetLayer를 대조하여 플레이어-코인(획득), 플레이어-적(충돌), 플레이어-데드라인(사망) 등의 물리 이벤트를 감별합니다.

Renderer: 모든 액터가 Submit한 데이터를 SortingOrder에 맞춰 정렬한 뒤, 이중 버퍼링(Present)을 통해 깜빡임 없이 출력합니다.

5. 상태 변화 및 목표 달성 (State Management)
   
실시간 감시: 게임 루프 내에서 승리 조건(모든 Enemy 제거) 및 패배 조건(DeathLine 접촉)을 지속적으로 체크합니다.

이벤트 트리거: 조건 충족 시 현재 GameLevel의 실행을 중단하고 EndLevel로 제어권을 넘깁니다.

6. 게임 종료 및 결과 리포팅 (Game Result & Exit)
   
결과 출력: EndLevel에서는 플레이 중 기록된 점수나 클리어 타임 등의 데이터를 사용자에게 시각화합니다.

리소스 정리: 애플리케이션 종료 시 소멸자를 통해 엔진이 점유했던 모든 메모리(ScreenBuffer, Level, Actor 등)를 안전하게 해제하여 메모리 누수를 방지합니다.

---

## 4. 주요 작업

### 🔸구현 기능 명칭

**1. 컴포넌트 기반 물리 및 중력 시스템**   

유니티의 Rigidbody 설계 방식을 차용하여, 액터가 독립적인 중력 로직을 가질 수 있도록 구현했습니다.

설계 의도: 물리 로직을 Actor 클래스에 하드코딩하지 않고, 필요에 따라 탈부착 가능한 컴포넌트 형태로 설계하여 확장성을 확보했습니다.

핵심 로직:

Actor 생성자 내 bool bUseGravity 변수를 도입하여 물리 적용 여부를 직관적으로 제어합니다.

StartGravity() 호출 시 해당 액터의 참조를 전역 물리 매니저(gravityActor 벡터)에 등록합니다.

등록된 액터들은 매 틱(Tick)마다 중력 및 위치 보정 계산을 자동으로 수행받게 됩니다.

장점: 특정 액터에 중력 기능을 부여하는 절차를 함수 호출 하나로 단순화하여 개발 생산성을 높였습니다.

<img width="1058" height="580" alt="image" src="https://github.com/user-attachments/assets/cd5c089a-5b38-455e-92c0-9e24e7f6225f" />


**2. 레이어 기반 충돌 필터링 및 이벤트 시스템**

단순한 좌표 겹침을 넘어, 레이어 시스템을 통해 충돌의 목적과 대상을 명확히 분리했습니다.

이중 레이어 구조 (Self & Target):

Self Layer: 객체 본인이 속한 그룹 (예: Player, Enemy, Wall).

Target Layer: 이 객체가 충돌을 감지하고 상호작용할 대상 그룹.

충돌 판정 프로세스: 

1.  AABB/순수 좌표 체크: 두 객체의 물리적 공간이 겹치는지 확인합니다.
2.  레이어 마스크 검사: A의 Target Layer == B의 Self Layer 인지 비교하여 유효한 충돌인지 필터링합니다.
3.  이벤트 발생: 조건이 충족될 때만 OnCollision 이벤트를 호출하여 불필요한 연산을 방지합니다.

장점: 아군 오사 방지, 특정 벽 통과 등 복잡한 상호작용 규칙을 레이어 설정만으로 손쉽게 관리할 수 있습니다.

<img width="1062" height="600" alt="image" src="https://github.com/user-attachments/assets/c501765a-7521-48cd-98a9-79aaf742ee85" />


**3. 추상화 기반 레벨 관리 시스템** 

유사한 구조를 가진 여러 레벨의 공통 로직을 템플릿화하여 코드 중복을 획기적으로 줄였습니다.

계층 구조: Level → BaseMenuLevel (Abstraction, Implementation) → SubMenuLevels (Implementation).

추상화 전략:  메뉴 UI 배치, 입력 핸들링, 화면 전환 등 모든 메뉴 레벨이 공유하는 핵심 로직을 BaseMenuLevel에 구현

상속받은 하위 클래스에서는 해당 레벨만의 특수 데이터(메뉴 항목 이름, 연결 기능 등)만 정의하도록 설계했습니다.

장점: 코드 재사용성을 극대화하고, 기능 수정 시 최상위 부모 클래스만 수정하면 모든 레벨에 반영되는 유지보수 편의성을 확보했습니다.

<img width="540" height="392" alt="image" src="https://github.com/user-attachments/assets/cd696bb1-0619-4e8b-a4e3-8eccaf7bf358" />


**4. 시퀀스 기반 적 공격 패턴**

사용자에게 시각적 예고를 제공하는 단계별 상태 머신(FSM) 형태의 공격 패턴을 구현했습니다.

공격 3단계 프로세스:

감지 및 경고 : 플레이어 진입 시 ! 아이콘 출력. (플레이어에게 회피 타이밍 인지 시킴)

범위 예고 : 하얀색 별 문자로 공격 유효 범위를 시각화.

타격 실행 (Action): 빨간색 X 표시와 함께 실제 데미지 판정 처리.

장점: 단순한 공격보다 '전조 현상 - 범위 표시 - 공격'으로 이어지는 연출을 콘솔 환경에서 효과적으로 구현했습니다.
<img width="990" height="232" alt="image" src="https://github.com/user-attachments/assets/8d311d8d-e49c-4623-8d76-b41437a30d99" />


각 Enemy 타입에 맞는 공격을 실행 코드
<img width="1004" height="350" alt="image" src="https://github.com/user-attachments/assets/f2df3e76-9e27-4c2d-a5d3-33b4924a8da6" />


---

## 5. 결과 및 회고

### 🔸결과

> 특정 게임을 만들고자 하여 개발한 것이 아니라 구현해 보고 싶은 기능을 위주로 제작을 하여 게임 자체의 완성도는 떨어졌습니다.
> 하지만 게임 자체의 재미나 분량 면에서는 아쉬움이 남을 수 있으나 실제 상용 엔진의 핵심 기술들을 내 손으로 직접 구현해 보았다는 점에서 큰 성취감을 느꼈습니다.
> 특히 물리 엔진을 구현하여 레이어를 나눠서 충돌처리를 하는 것과 Level을 한번에 묶어서 관리하는 것이 엔진의 구조적 이해도를 높이는 데 결정적인 역할을 했습니다.


### 🔸회고

> 기존에 개발을 할 때 70% 이상 AI를 사용하여서 제작을 하고 있어서 AI의 의존도를 줄이려고 노력을 하였습니다.
> 줄이기는 하였지만 아직 40% 이상은 도움을 받고 있어 다음 프로젝트에서는 더 줄이도록 노력 할 것입니다.
> 시간이 넉넉하지 않아서 2번째 적 공격, 엔딩 구현이라던지 완성도가 떨어져서 아쉽습니다.

---

## 시각자료

https://github.com/user-attachments/assets/b298377d-d6f5-416d-8d6e-72b211596722



